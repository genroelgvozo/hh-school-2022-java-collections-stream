package tasks;

import common.Person;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/*
А теперь о горьком
Всем придется читать код
А некоторым придется читать код, написанный мною
Сочувствую им
Спасите будущих жертв, и исправьте здесь все, что вам не по душе!
P.S. функции тут разные и рабочие (наверное), но вот их понятность и эффективность страдает (аж пришлось писать комменты)
P.P.S Здесь ваши правки желательно прокомментировать (можно на гитхабе в пулл реквесте)
 */
public class Task8 {

  private static final int FAKE_PERSONS = 1;

  //Не хотим выдывать апи нашу фальшивую персону, поэтому конвертим начиная со второй
  public List<String> getNames(List<Person> persons) {
    return persons.stream()
        .skip(FAKE_PERSONS)
        .map(Person::getFirstName)
        .collect(Collectors.toList());
  }
  // многие называли причину как долгие ремув - O(n)
  // но многие забывали что так же можно передать List.of() (метод же лист принимает, я имею права), и все вообще работать не будет
  // как урок - всегда помните что все может быть неизменяемым, никогда не меняйте параметры - юзер вашего метода спасибо не скажет

  //ну и различные имена тоже хочется
  // тут вообще ноукомментс, потому что идея за вас все делает) но кто-то ее не слушал (как и меня на лекции)
  public Set<String> getDifferentNames(List<Person> persons) {
    return new HashSet<>(getNames(persons));
  }

  //Для фронтов выдадим полное имя, а то сами не могут
  // тут я в смятении
  // очень много видел решений через стрим с первой попытки.. и вроде бы хорошо, но.. так никогда не было)
  // этот метод хорошо выглядит через стрим, но это самое наверное не логичное для новичков использование его,
  // тот самый пример когда стрим не из коллекции что-то может
  // надеюсь вы не подглядывали в чужие ПРы Ж))
  // а так - суть в том, что в бизнес коде я хочу прочесть и понять "что он делает" быстрее чем отглотнуть пивка из банки
  // скорости низкоуровневость не добавит, а вот вероятность ошибки увеличит. И читаемость уменьшит
  public String convertPersonToString(Person person) {
    return Stream.of(person.getSecondName(), person.getFirstName(), person.getMiddleName())
        .filter(Objects::nonNull)
        .filter(Predicate.not(String::isBlank))
        .collect(Collectors.joining(" "));
    // читаем - возьми, фильтруй не налл, фильтруй не пустые, сджойни
    // и никаких ошибок с пробелами лишними где  бы то ни было, никаких вложенных ифов, тримов, регэкспов, чего вы только не придумывали)
  }

  // словарь id персоны -> ее имя
  public Map<Integer, String> getPersonNames(Collection<Person> persons) {
    return persons.stream()
        .collect(Collectors.toMap(
            Person::getId,
            this::convertPersonToString,
            (a, b) -> a   // тут суть была вспомните ли вы этот нюанс
            // (и заметите ли иф в изначально коде, который намекал, хоть и без него бы ничего не падало)
        ));
  }

  // есть ли совпадающие в двух коллекциях персоны?
  public boolean hasSamePersons(Collection<Person> persons1, Collection<Person> persons2) {
    return persons1.stream().anyMatch(new HashSet<>(persons2)::contains); // это мой фаворит, потому что явно сказно че происходит
    // еще можно !Collections.disjoint(new HashSet<>(persons1), persons2)
    // ну или в обоих вариантах не превращать в сет, если не надо гарантированно быстро (сейчас O(n), без него так же может быть линейное, но если обе коллекции List - то O(n^2))
    // на вопрос сколько работает 1 или 2 вариант (без сета) частенько отвечали O(n^2), тут сразу понимаю что к интерфейсам еще не привыкли
    // вообщем нельзя ответить за сколько, все зависит от того какая реальная коллекция там приходит, тут можно передать и лист и сет
    // и это кстати нормально писать именно такие дженерные методы
  }

  //...
  public long countEven(Stream<Integer> numbers) {
    return numbers.filter(num -> num % 2 == 0).count(); // не самый удачные метод для задачки, но решил оставить
    // суть в чем - count++ операция не атомарная, и если стрим параллельный - результат неправильный (при большом кол-ве чисел естественно)
    // тут вообще все плохо, не стоит stream в таких случаях передавать, но это было больше на догадку про параллельность
    // приватное поле как выпоняли было читом - чтобы считалось effectively final
  }
}
